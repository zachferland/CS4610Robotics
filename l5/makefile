# Vona's super-ninja makefile (mostly for Java)
#
# *** DO NOT EDIT THIS FILE EXCEPT IN THE PROJECT HOME DIRECTORY ***
#
# This makefile is auto-generated by "make makefiles" in the parent package
#
# You should edit makefile.project, which is included below, to specify
# project-specific settings.
#
# You should edit makefile.package, which is also included below, to specify
# package-specific targets and variables.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc., 59
# Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Copyright (c) 2011 Marsette A. Vona
#
# $Id: makefile 1868 2013-03-14 17:56:36Z vona $

# Relative path to the directory containing the root package for the project.
# For makefile in every directory other than $(PROJECT_HOME) this is
# automatically set by "make makefiles"
PROJECT_HOME = .

SHELL = /bin/bash

WWWROOT = $(HOME)/www

#figure out arch
SYSTEM := $(shell uname -s | tr " " "_")
MACHINE := $(shell uname -m | tr " " "_")
ARCH := $(SYSTEM)_$(MACHINE)

# the default target
default: package

# prevent make from always trying to remake makefiles
makefile.package makefile.project: ;

-include $(PROJECT_HOME)/makefile.project

ifndef BASE_PACKAGE
BASE_PACKAGE := $(notdir $(shell cd $(PROJECT_HOME) && pwd))
endif

ifndef APPNAME
APPNAME := $(BASE_PACKAGE)
endif

# function to convert a package name to a path
package-to-path = $(subst .,/,$(1))

# function to extract the package part of a full class name (not including
# the trailing .class)
package-part = $(basename $(1))

# function to extract the class part of a full class name (not including the
# trailing .class)
class-part = $(subst .,,$(suffix $(1)))

# The (full) name of this package.  For makefile in every directory other than
# $(PROJECT_HOME) this is automatically set by "make makefiles"
PACKAGE = $(BASE_PACKAGE)

# misc macros

# these let $(COMMA) and $(SPACE) be lone arguments to make function calls
COMMA := ,
EMPTY :=
SPACE := $(EMPTY) $(EMPTY)

# whitespace regex
WS = [ \t]*

ifneq ($(findstring CYGWIN,$(SYSTEM)),CYGWIN)
# make cd .. follow the Physical directory structure on Unix
CD = cd -P
else
CD = cd
# always use bash on cygwin, sh doesn't have pushd, but bash slows things down
SHELL = `which bash`
endif

# tool finding functions

#locate the target of a symlink
#
#works even if the starting point is not a symlink
locate-target = $(shell f="$(1)"; while [ -L "$$f" ]; do f=`ls -l "$$f" | awk '{print $$NF}'`; done; echo "$$f")

#try hard to find a command 
#
#first arg is command name
#
#second arg is expected directory
#
#if cmd executable in directory, that is returned
#
#else if which knows where the command is, that is returned
#
#else empty string is returned
locate-cmd = $(shell if [ -x "$(2)/$(1)" ]; then echo "$(2)/$(1)"; else cmd="$(shell which "$(1)" 2>/dev/null || true)" && if [ -x "$$cmd" ] ; then echo "$$cmd"; else echo ""; fi; fi)

#get the parent directory name
#
#better than the make builtin function because this also works on a directory
dirname = $(shell if [[ "$(1)"x != x && -e "$(1)" ]]; then dirname "$(1)"; else echo ""; fi)

#default a dir
#
#first arg is the desired dir
#
#second is the default dir
#
#returns first arg iff it's a directory, else second arg
default-dir = $(shell if [ ! -d "$(1)" ]; then echo "$(2)"; else echo "$(1)"; fi)

# find tool directories

ifndef TOOLS_HOME
TOOLS_HOME := $(call default-dir,$(PROJECT_TOOLS_HOME),/usr)
endif

BIN := $(call default-dir,$(TOOLS_HOME)/bin/$(ARCH),/usr/bin)
SCRIPTS := $(call default-dir,$(TOOLS_HOME)/scripts,$(BIN))

ifndef JDK_BASE
JDK_BASE := $(TOOLS_HOME)/java/$(ARCH)
endif 

ifndef JDK_VERSION
JDK_VERSION := newest
endif

ifndef JDK_HOME
JDK_HOME := $(call dirname,$(call dirname,$(call locate-target,$(call locate-cmd,javac,$(JDK_BASE)/$(JDK_VERSION)/bin))))
endif
JDK_EXT := $(JDK_HOME)/jre/lib/ext

ifeq ($(SYSTEM),Darwin)
JDK_EXT := /System/Library/Java/Extensions
endif

ifndef TOOLS_EXT
TOOLS_EXT := $(TOOLS_HOME)/java/indep/lib
endif

TOOLS_JAR := $(JDK_HOME)/lib/tools.jar

ifeq ($(SYSTEM),Darwin)
TOOLS_JAR := /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Classes/classes.jar
endif

# find pure java extension jars in TOOLS_EXT if present, else in JDK_EXT
#
# NOTE the classes will come in on different classloaders in the two cases,
# which can lead to subtle CNFEs
ifndef EXT_DIR
EXT_DIR := $(call default-dir,$(TOOLS_EXT),$(JDK_EXT))
endif

# JDK executables
JAVAC := $(call locate-cmd,javac,$(JDK_HOME)/bin)
ifndef JAVA
JAVA := $(call locate-cmd,java,$(JDK_HOME)/bin)
endif
JAVADOC := $(call locate-cmd,javadoc,$(JDK_HOME)/bin)
JAR := $(call locate-cmd,jar,$(JDK_HOME)/bin)
KEYTOOL := $(call locate-cmd,keytool,$(JDK_HOME)/bin)
JARSIGNER := $(call locate-cmd,jarsigner,$(JDK_HOME)/bin)
RMIC := $(call locate-cmd,rmic,$(JDK_HOME)/bin)

#other executables
JAVACC := $(call locate-cmd,javacc,$(BIN))
RSYNC := $(call locate-cmd,rsync,$(BIN))
WWWIMAGESIZE := $(call locate-cmd,wwwimagesize,$(SCRIPTS))
SVNVERSION := $(call locate-cmd,svnversion,$(BIN))

# CompileServer stuff

# the CompileServer binary directory
CS_BIN := $(call dirname,$(call locate-target,$(call locate-cmd,javac_submit,$(BIN))))

# the CompileServer scripts directory
CS_SCRIPTS := $(call dirname,$(call locate-target,$(call locate-cmd,CompileServer-submit,$(SCRIPTS))))

# define NO_COMPILE_SERVER to disable compile server 
ifndef NO_COMPILE_SERVER

CS_ENSURE := $(call locate-cmd,CompileServer-ensure-running,$(CS_SCRIPTS))
CS_SUBMIT := $(call locate-cmd,CompileServer-submit,$(CS_SCRIPTS))

ifdef CS_ENSURE

ifeq ($(findstring OK,$(shell $(CS_ENSURE) nostart)),OK)

ifdef CS_SUBMIT

#ok CompileServer is all good!
JAVAC := $(CS_SUBMIT)
USING_COMPILE_SERVER := 1

endif

endif #OK

endif #CS_ENSURE

endif #NO_COMPILE_SERVER

# svnversion stuff

SVNVERSION_FILE := SVNVERSION.txt

ifdef SVNVERSION_FILE_NOAUTO
SVNVERSION_FILE_DEP =
else
SVNVERSION_FILE_DEP := $(SVNVERSION_FILE)
endif

SVNVERSION_STRING := $(if $(wildcard $(SVNVERSION_FILE)),R$(subst $(SPACE),_,$(filter-out %die,$(subst :,die ,$(strip $(shell cat $(SVNVERSION_FILE)))))),unknown)

JARFILE_PAT := $(subst SVNVERSION,R*,$(JARFILE))
JARFILE_LITE_PAT := $(subst SVNVERSION,R*,$(JARFILE_LITE))
JARFILE_XLITE_PAT := $(subst SVNVERSION,R*,$(JARFILE_XLITE))

JARFILE_NEWEST := $(subst SVNVERSION,newest,$(JARFILE))
JARFILE_LITE_NEWEST := $(subst SVNVERSION,newest,$(JARFILE_LITE))
JARFILE_XLITE_NEWEST := $(subst SVNVERSION,newest,$(JARFILE_XLITE))

JARFILE_SUBST := $(subst SVNVERSION,$(SVNVERSION_STRING),$(JARFILE))
JARFILE_LITE_SUBST := $(subst SVNVERSION,$(SVNVERSION_STRING),$(JARFILE_LITE))
JARFILE_XLITE_SUBST := $(subst SVNVERSION,$(SVNVERSION_STRING),$(JARFILE_XLITE))
JARFILE_PUBLISH_UNPACK_SUBST := $(subst SVNVERSION,$(SVNVERSION_STRING),$(JARFILE_PUBLISH_UNPACK))

# rmi stuff

# generate commands to run RMIWrap
#
# first arg is the (simple) name of the API interface
#
# second arg is the (simple) name of the implementation class
run-rmiwrap = if [ ! -f $(1)Remote.java -o ! -f $(2)Server.java -o ! -f $(2)Client.java -o \( $(1).java -nt $(1)Remote.java \) -o \( $(2).java -nt $(2)Client.java \) -o \( $(2).java -nt $(2)Server.java \) ]; then $(JAVA) $(RUN_JAVA_FLAGS) vona.rmi.rmiwrap.RMIWrap $(PACKAGE).$(1) $(PACKAGE).$(2) && $(JAVAC) $(JAVAC_FLAGS) *.java; fi

# generate commands to run rmic
#
# first arg is the (simple) name of the remote class for which to generate a
# stub
RMIC_JRMP_VERSION = 1.1
run-rmic = if [ ! -f $(1)_Stub.class -o $(1).class -nt $(1)_Stub.class ]; then $(RMIC) -v$(RMIC_JRMP_VERSION) -d $(PROJECT_HOME)/.. $(CLASSPATH_FLAG) $(PACKAGE).$(1); fi

# rsync stuff

# flags for rsync
#
# excludes the usual suspects
ifndef RSYNC_LINKS
RSYNC_LINKS := --links --safe-links
endif

RSYNC_FLAGS := -rv $(RSYNC_LINKS) --progress --exclude "**~" --exclude ".\#**" --exclude CVS --exclude .svn --exclude "*.tmp"

# rsync first arg to second arg, with cvs exclude
rsync = $(RSYNC) $(RSYNC_FLAGS) --cvs-exclude $(1) $(2)

# rsync a subproject
#
# symlinks are copied as symlinks, and symlinks that point outside the tree are
# not copied
#
# first arg is filename extension to include (starting with ".", or empty for
# all)
#
# second arg is the name of a subproject (i.e. the name of the base package of
# the subproject).  If it ends in "." then it is copied non-recursively, else
# it is copied recursively.
#
# third arg is rsync dest, if not absolute then relative to $(PROJECT_HOME)/..
#
rsync-subproject = pushd $(PROJECT_HOME)/.. && $(RSYNC) $(RSYNC_FLAGS) --include "*/" --exclude "/$(BASE_PACKAGE)/$(JAVADOC_DIR_NAME)/**" --exclude "*.jar" --include $(if $(filter ".","$(suffix $(2))"),"/$(call package-to-path,$(basename $(2)))/*$(1)","/$(call package-to-path,$(2))/**$(1)") --exclude "*" $(BASE_PACKAGE) $(3) && popd

# this should have dynamic binding so that makefile.package can override
# JARFILE
JAR_DIR = .$(JARFILE).tmp

# make a jar
#
# does not include hidden files (any file with name beginning ".")
#
# if .class files are included in the jar, they are always updated with later
# timestamps than other files in the jar, so that javac should not decide it
# needs to recompile things if a jar with both .java and corresp .class files
# is put on a javac classpath
#
# arg 1: "true" to include javadoc tree, "false" otherwise
#
# arg 2: the list of external jars (none if empty)
#
# arg 3: the (versioned) name of the jarfile
#
# arg 4: the list of filename extensions to include (each beginning with ".",
# empty to include all)
#
# arg 5: list of extra files to include iff arg 4 is not empty (pathnames
# relative to parent of base package, files must be present and must not be
# already included by arg 4)
#
# arg 6: includes only files in these subproject packages
#
# arg 7: the (newest) name of the jarfile
#
# arg 8: (optional) extra commands to prepare $(JAR_DIR)
#

FIND_NOT_HIDDEN = find . -not -type d -a -not -name ".*"
COUNT_NOT_HIDDEN = $(FIND_NOT_HIDDEN) | wc -l
FIND_CLASSES = $(FIND_NOT_HIDDEN) -a -name "*.class"
COUNT_CLASSES = $(FIND_CLASSES) | wc -l
find-by-ext = \
	$(FIND_NOT_HIDDEN) -a "(" -false $(foreach E,$(1),-o -name "*$(E)" ) ")"
count-by-ext = $(call find-by-ext,$(1)) | wc -l

make-jar = \
	$(RM) $(3) && \
	$(RM) -r $(JAR_DIR) && \
	mkdir $(JAR_DIR) && \
	if [[ $(1) && -d "$(JAVADOC_DIR)" ]]; then \
    $(call rsync,$(JAVADOC_DIR),$(JAR_DIR)); \
  fi && \
	if [ "$(4)"x == x ]; then \
	$(foreach P,$(6),$(call rsync-subproject,,$(P),$(call package-to-path,$(PACKAGE))/$(JAR_DIR)) && ) true; \
	else $(foreach E,$(4),$(foreach P,$(6),$(call rsync-subproject,$(E),$(P),$(call package-to-path,$(PACKAGE))/$(JAR_DIR)) && )) true; fi && \
	$(foreach F,$(addprefix $(EXT_DIR)/,$(2)),cp $(F) $(JAR_DIR) &&) true && \
	$(foreach F,$(5),cp $(addprefix $(PROJECT_HOME)/../,$(F)) $(JAR_DIR)/$(dir $(F)) &&) true && \
	( true; $(8) ) && \
	$(CD) $(JAR_DIR) && \
	$(foreach F,$(2),$(JAR) xvf $(F) && rm $(F) &&) true && \
	rm -rf META-INF && \
	if [ "$(4)"x == x ]; then \
		if [ `$(COUNT_NOT_HIDDEN)` -gt 0 ]; then \
			$(JAR) cvf $(3) `$(FIND_NOT_HIDDEN)` && \
			if [ `$(COUNT_CLASSES)` -gt 0 ]; \
	      then $(JAR) uvf $(3) `$(FIND_CLASSES)`; \
	    fi; \
		else echo "not creating jar, no non-hidden input files"; \
		fi; \
	else \
	  if [[ `$(call count-by-ext,$(4))` -gt 0 || "$(5)"x != x ]]; then \
		  $(JAR) cvf $(3) `$(call find-by-ext,$(filter-out .class,$(4)))` $(5) && \
		  if [ `$(COUNT_CLASSES)` -gt 0 ]; then \
	      $(JAR) uvf $(3) `$(call find-by-ext,$(filter .class,$(4)))`; \
			fi; \
		else echo "not creating jar, no non-hidden input files"; \
		fi; \
	fi && \
	if [ -f $(3) ]; then \
		if [ -f ../$(JAR_MF) ]; then $(JAR) ufm $(3) ../$(JAR_MF); fi && \
		if [ -f ../$(JAR_CRT) ]; then $(JARSIGNER) $(3) $(JARKEY); fi && \
		chmod a+r $(3); \
		mv $(3) ..; \
	fi && \
	$(CD) .. && \
	rm -rf $(JAR_DIR) && \
	if [[ ! -a $(7) || -h $(7) ]]; then ln -s -f $(3) $(7); fi


# template file locations
TEMPLATE_DIR = $(PROJECT_HOME)/templates
JAVA_TEMPLATE = $(TEMPLATE_DIR)/Template.java
EXCEPTION_TEMPLATE = $(TEMPLATE_DIR)/Exception.java
PACKAGE_TEMPLATE = $(TEMPLATE_DIR)/package.html
MAKEFILE_PACKAGE_TEMPLATE = $(TEMPLATE_DIR)/makefile.package

template-m4-common =  m4 -P "-DYEAR=`date +%Y`" "-DPACKAGE=$(PACKAGE)"
template-m4-java =  m4 -P "-DYEAR=`date +%Y`" "-DPACKAGE=$(PACKAGE)" "-DCLASS=$(notdir $(basename $(1)))" $(JAVA_TEMPLATE) > $(basename $(1)).java

# function to generate a javadoc command line
#
# javadoc will be deposited in $(JAVADOC_DIR)
#
# first arg is list of base packages.  Javadoc will be built for all
# subpackages of the base packages, except those specifically excluded in the next arg
#
# second arg, if any, is a list of packages to specifically exclude
javadoc = $(JAVADOC) $(JAVADOC_FLAGS) -d $(JAVADOC_DIR) $(foreach P,$(1), -subpackages $(P)) $(foreach P,$(2), -exclude $(P))

# function to make a target recursively
# first argument is target to make
# second argument is "true" to continue on fail, "false" to stop on fail
recursively-make = $(foreach DIR,$(PACKAGE_SUBDIRS),[ ! -d $(DIR) ] || pushd $(DIR) > /dev/null && ( $(MAKE) $(1) || $(2) ) && popd > /dev/null && ) true

# function to make something from $(PROJECT_HOME)
make-from-project-home = \
	@echo making $(1) from $(PROJECT_HOME); \
	$(CD) $(PROJECT_HOME) && $(MAKE) $(1)

# compute short package name from fullname
PACKAGE_NAME = $(subst .,,$(suffix .$(PACKAGE)))

# compute project name (root package name) from package fullname
PROJECT = $(firstword $(subst ., ,$(PACKAGE)))

# heap size flag
MEMORY_FLAG = -Xmx$(TOTAL_HEAP_SIZE)

# compute the package path from the package full name
# $(PROJECT_HOME)/../$(PACKAGE_PATH) is a path to this package
PACKAGE_PATH = $(call package-to-path,$(PACKAGE))

# command to run make without generating any extraneous output
MAKE_SILENT = $(MAKE) --silent --no-print-directory 

# is this the project root package?
ifeq ($(PROJECT_HOME),.)
ROOT_PACKAGE = yes
endif

# source the package-specific makefile
# do this before building classpath so that EXT_JARS can be frobbed
-include makefile.package

# flag useful for various tools

# put the parent of project home first on the classpath
# that way if there are built checkouts of the source trees for any EXT_JARS
# then we'll pick up those classes directly from there
NINJA_CLASSPATH := $(PROJECT_HOME)/..

ifdef USING_COMPILE_SERVER
NINJA_CLASSPATH := $(shell pwd)/$(NINJA_CLASSPATH)
endif

# now put each EXT_JAR on the classpath, in order, but only if we're finding
# them in an EXT_DIR which is not the JDK installed extensions dir
ifneq ($(EXT_DIR),$(JDK_EXT))
NINJA_CLASSPATH := $(subst $(SPACE),,$(NINJA_CLASSPATH)$(foreach JAR,$(EXT_JARS),:$(EXT_DIR)/$(JAR)))
endif

# next add the JDK tools jar to the classpath
# in particular, for use by CompileServer
NINJA_CLASSPATH := $(NINJA_CLASSPATH):$(TOOLS_JAR)

# finally append the user's externally defined CLASSPATH, if any
ifdef CLASSPATH
MAKE_CLASSPATH := $(NINJA_CLASSPATH):$(CLASSPATH)
else
#trailing colon breaks java under Windows
MAKE_CLASSPATH := $(NINJA_CLASSPATH)
endif

# important: only consider for compilation sourcefiles that are found within
# this project (and e.g. not within jars on the classpath)
ifdef SOURCEPATH
MAKE_SOURCEPATH := $(PROJECT_HOME)/..:$(SOURCEPATH)
else
MAKE_SOURCEPATH := $(PROJECT_HOME)/..
endif

ifeq ($(findstring CYGWIN,$(SYSTEM)),CYGWIN)
MAKE_CLASSPATH := `cygpath -w -p "$(MAKE_CLASSPATH)"`
MAKE_SOURCEPATH := `cygpath -w -p "$(MAKE_SOURCEPATH)"`
endif

CLASSPATH_FLAG = -classpath "$(MAKE_CLASSPATH)"

SOURCEPATH_FLAG = -sourcepath "$(MAKE_SOURCEPATH)"

DEPRECATION_FLAG = -deprecation

# always exclude these subdirs
EXCLUDE_SUBDIRS += . .. CVS .svn $(wildcard gen-images-*)

# figure out our subdirs
PACKAGE_SUBDIRS = $(filter-out $(EXCLUDE_SUBDIRS),$(notdir $(shell find . -maxdepth 1 -type d -not -name ".*.tmp" -a -not -name "javadoc-*")))

# always exclude these source files
EXCLUDE_SOURCE +=

# figure out source files
PACKAGE_JAVAC_SOURCE := $(filter-out $(wildcard $(EXCLUDE_SOURCE)),$(wildcard *.java))
PACKAGE_HTML_SOURCE := $(sort $(filter-out $(wildcard $(EXCLUDE_SOURCE)),$(wildcard *.phtml *.m4 *.md *.m4d)))
PACKAGE_JAVACC_SOURCE := $(filter-out $(wildcard $(EXCLUDE_SOURCE)),$(wildcard *.jj))

GEN_MD := $(filter %.m4d,$(PACKAGE_HTML_SOURCE))
GEN_MD := $(GEN_MD:.m4d=.md)

# ALL source 
SOURCE = \
	$(wildcard *.java) \
	$(wildcard *.scm) \
	$(wildcard *.c *.cc *.h *.hh) \
	$(wildcard *.mf) \
	$(wildcard *.jj) \
	$(wildcard *.xsd *.xml *.spp) \
	$(wildcard *.txt *.tex *.html *.htm *.css README) \
	$(wildcard *.properties *.conf *.xcf *.gif *.jpg *.png *.bmp *.ico) \
	$(wildcard *.lws *.lwo *.wrl) \
	$(wildcard *.sh *.csh *.bat *.iss) \
	$(wildcard *.phtml *.m4 *.md *.m4d) \
	$(wildcard *.policy) \
	package.html makefile.package

SOURCE := $(sort $(SOURCE))

PACKAGE_HTML_DEPS := $(addsuffix .html,$(basename $(PACKAGE_HTML_SOURCE)))
PACKAGE_JAVACC_DEPS := $(addsuffix .class,$(basename $(PACKAGE_JAVACC_SOURCE)))
PACKAGE_JAVAC_DEPS := $(addsuffix .class,$(basename $(PACKAGE_JAVAC_SOURCE)))

HTML_M4_EXTRA_DEPS += $(wildcard html-*.m4)

PACKAGE_DEPS = \
$(if $(NO_SOURCE_GEN),,package-source-gen) \
$(if $(NO_HTML),,package-html) \
package-javac

ifdef ROOT_PACKAGE
SOURCE += makefile makefile.project
endif

# compile-time flags
JAVAC_FLAGS += $(DEPRECATION_FLAG) $(CLASSPATH_FLAG) -source $(SOURCE_VERSION) -target $(TARGET_VERSION)  $(JAVAC_OPTIONS)

# unfortunately, -sourcepath seems buggy with compileserver
ifndef USING_COMPILE_SERVER
JAVAC_FLAGS += $(SOURCEPATH_FLAG)
endif

ifndef NATIVE_EXT_DIR
NATIVE_EXT_DIR = $(EXT_DIR)/../..
endif

ifneq ($(findstring CYGWIN,$(SYSTEM)),CYGWIN)
#JAVA_PREFIX := $(if $(NATIVE_LIB_NOAUTO),,"LD_LIBRARY_PATH=$(NATIVE_EXT_DIR)/native/lib/$(ARCH):$(LD_LIBRARY_PATH)")
NATIVE_LIB_FLAG := $(if $(NATIVE_LIB_NOAUTO),,"-Djava.library.path=$(NATIVE_EXT_DIR)/native/lib/$(ARCH):/usr/lib/jni:$(LD_LIBRARY_PATH)")
endif

# runtime flags
RUN_JAVA_FLAGS += $(CLASSPATH_FLAG) $(MEMORY_FLAG) $(NATIVE_LIB_FLAG) $(WORKAROUND_FLAGS) $(JAVA_OPTIONS) -ea

# javadoc flags
JAVADOC_FLAGS += $(CLASSPATH_FLAG) -source $(JAVADOC_SOURCE_VERSION) -private -use -author -doctitle $(APPNAME) `if [ -e overview.html ]; then echo -overview overview.html; else echo ""; fi`

# subpackage makefiles
SUBPACKAGE_MAKEFILES = $(addsuffix /makefile,$(PACKAGE_SUBDIRS))

# HTML stuff
.SUFFIXES:	.m4 .phtml .html .md .m4d
HTML_GEN_DEFS += "-DBUILD_DATE=`date`" "-DYEAR=`date +%Y`" "-DSVNVERSION_STRING=$(SVNVERSION_STRING)" $(if $(SUPPRESS_HTML_PARENT_PATH),"-DSUPPRESS_HTML_PARENT_PATH=true") 
HTML_GEN_INC += "-I$(WWWROOT)/include" 
PANDOC_HTML_OPTS += --standalone --smart --gladtex
html-cpp = gcc -E -P -traditional $(HTML_GEN_DEFS) $(HTML_GEN_INC) $(HTML_CPP_EXTRA) - < $(1) > $(2)
html-m4 = m4 -P $(HTML_GEN_DEFS) $(HTML_GEN_INC) $(HTML_M4_EXTRA) $(1) > $(2)
md-m4d = m4 -P $(HTML_GEN_DEFS) $(HTML_GEN_INC) $(MD_M4D_EXTRA) $(1) > $(2)
htex-md = pandoc $(PANDOC_HTML_OPTS) -o $(2) $(1)
html-htex = \
  if [[ ! -d gen-images-$(basename $(2)) ]]; then mkdir gen-images-$(basename $(2)); fi && \
	gladtex $(GLADTEX_OPTS) -d gen-images-$(basename $(2)) $(1) && \
	if [[ `ls gen-images-$(basename $(2))/*.png 2> /dev/null | wc -l` == 0 ]]; then $(RM) -rf gen-images-$(basename $(2)); fi
wwwimagesize = if [ -x "$(WWWIMAGESIZE)" ]; then $(WWWIMAGESIZE) -MakeBackup no $(1); fi

# use this target as a prereq to force another target
.PHONY: FORCE
FORCE:

# pattern rules

# initialize a new class file
%.java-template: $(JAVA_TEMPLATE)
	if [ ! -f ./$(basename $@).java ] || [ ! -s ./$(basename $@).java ]; then $(call template-m4-java,$@); else echo ./$(basename $@).java exists and is non-empty, not overwriting; fi

.PHONY: java-templates
java-templates:
	$(foreach F,$(shell find . -maxdepth 1 -size 0 -name "*.java"),$(call template-m4-java,$F); )

# initialize a new Exception class file
%.java-exception-template: $(EXCEPTION_TEMPLATE)
	if [ ! -f ./$(basename $@).java ]; then cp $(EXCEPTION_TEMPLATE) ./$(basename $@).java; else echo ./$(basename $@).java exists, not overwriting; fi

# initialize a new package.html file 
.PHONY: package.html-template
package.html-template: $(PACKAGE_TEMPLATE)
	if [ ! -f package.html ]; then cp $(PACKAGE_TEMPLATE) ./package.html; else echo ./package.html exists, not overwriting; fi

# initialize a new makefile.package file 
.PHONY: makefile.package-template
makefile.package-template: $(MAKEFILE_PACKAGE_TEMPLATE)
	if [ ! -f makefile.package ]; then cp $(MAKEFILE_PACKAGE_TEMPLATE) ./makefile.package; else echo ./makefile.package exists, not overwriting; fi

# make html from m4
%.html: %.m4 $(SVNVERSION_FILE_DEP) $(HTML_M4_EXTRA_DEPS)
	$(MAKE) $@-m4-impl
%.html-m4-impl:
	$(call html-m4,$(basename $@).m4,$(basename $@).html)
	$(call wwwimagesize $(basename $@).html)

# make html from phtml by sending it through the C pre-processor
%.html: %.phtml $(SVNVERSION_FILE_DEP) $(HTML_PHTML_EXTRA_DEPS)
	$(MAKE) $@-phtml-impl
%.html-phtml-impl:
	$(call html-cpp,$(basename $@).phtml,$(basename $@).html)
	$(call wwwimagesize $(basename $@).html)

# make md from m4d (markdown)
%.md: %.m4d $(SVNVERSION_FILE_DEP) $(MD_M4D_EXTRA_DEPS)
	$(MAKE) $@-m4d-impl
%.md-m4d-impl:
	$(call md-m4d,$(basename $@).m4d,$(basename $@).md)

# make htex from md (markdown with latex math)
%.htex: %.md $(SVNVERSION_FILE_DEP) $(HTEX_MD_EXTRA_DEPS)
	$(MAKE) $@-md-impl
%.htex-md-impl:
	$(call htex-md,$(basename $@).md,$(basename $@).htex)

# make html from htex (markdown with latex math)
%.html: %.htex $(SVNVERSION_FILE_DEP) $(HTML_HTEX_EXTRA_DEPS)
	$(MAKE) $@-htex-impl
%.html-htex-impl:
	$(call html-htex,$(basename $@).htex,$(basename $@).html)
	$(call wwwimagesize $(basename $@).html)

# build a .class file from a .java file

ifeq ($(findstring CYGWIN,$(SYSTEM)),CYGWIN)

#fix paths on cygwin. ARGH...

ifdef USING_COMPILE_SERVER
%.class: %.java
	$(JAVAC) $(JAVAC_FLAGS) "`cygpath -w "$(addprefix $(shell pwd)/,$<)"`"
else
%.class: %.java
	$(JAVAC) $(JAVAC_FLAGS) $<
endif

else

# not on cygwin.  Phew.

%.class: %.java
	$(JAVAC) $(JAVAC_FLAGS) $<

endif

# build Java source files from a .jj grammar file
%.java: %.jj
	$(JAVACC) $<

# run a class in a specific package
$(PROJECT).%.run: $(if BUILD_BEFORE_RUN,$(PROJECT).%.class,)
	$(JAVA_PREFIX) $(JAVA) $(RUN_JAVA_FLAGS) $(basename $@)

# run a class in the current package with a main() function directly
%.run: $(if BUILD_BEFORE_RUN,%.class,)
	$(JAVA_PREFIX) $(JAVA) $(RUN_JAVA_FLAGS) $(PACKAGE).$(basename $@) 

# run a class in appletviewer (specify html filename without path or extension)
%.appletviewer:
	$(JDK_HOME)/bin/appletviewer $(basename $@).html

# build a class in a specific package
$(PROJECT).%.class:
	$(CD) $(PROJECT_HOME)/../$(call package-to-path,$(call package-part,$(basename $@))) && $(MAKE) $(call class-part,$(basename $@)).class

# build a specific package
$(PROJECT).%.package-make:
	@echo making package $@
	$(CD) $(PROJECT_HOME)/../$(call package-to-path,$(basename $@)) && $(MAKE) package

# recursive build of the base package is a project build
# note the semicolon which makes this an "empty command"!!
# without it the %.recursive pattern would get called after this runs
# resulting in an infinite loop!!
$(PROJECT).package-make.recursive: project ;

# build a specific package and all descendant packages
$(PROJECT).%.package-make.recursive:
	@echo making package $@ and all descendant packages
	$(CD) $(PROJECT_HOME)/../$(call package-to-path,$(basename $(basename $@))) && $(MAKE) package.recursive

# trick make into building the base package when asked
# if we don't do this then a spurious implicit rule gets invoked because the
# base package has no .suffix
$(PROJECT).package-make:
	@echo making base package
	$(CD) $(PROJECT_HOME) && $(MAKE) package

# recursively make something
%.recursive:
#	@echo recursively making $(basename $@)
	$(MAKE) $(basename $@)
	$(call recursively-make,$@,true)

# utility targets

.PHONY: show-exclude-source
show-exclude-source:
	@echo $(EXCLUDE_SOURCE)

.PHONY: show-exclude-subdirs
show-exclude-subdirs:
	@echo $(EXCLUDE_SUBDIRS)

.PHONY: show-package
show-package:
	@echo $(PACKAGE)

.PHONY: show-project-home
show-project-home:
	@echo $(PROJECT_HOME)

.PHONY: show-classpath
show-classpath:
	@echo $(MAKE_CLASSPATH)

.PHONY: show-sourcepath
show-sourcepath:
	@echo $(MAKE_SOURCEPATH)

.PHONY: show-jdk-home
show-jdk-home:
	@echo $(JDK_HOME)

.PHONY: show-jdk-ext
show-jdk-ext:
	@echo $(JDK_EXT)

.PHONY: show-tools-ext
show-tools-ext:
	@echo $(TOOLS_EXT)

.PHONY: show-tools-jar
show-tools-jar:
	@echo $(TOOLS_JAR)

.PHONY: show-ext-dir
show-ext-dir:
	@echo $(EXT_DIR)

.PHONY: show-java
show-java:
	@echo $(JAVA_PREFIX) $(JAVA)

.PHONY: show-run-java-flags
show-run-java-flags:
	@echo $(RUN_JAVA_FLAGS)

.PHONY: show-run-java-with-flags
show-run-java-with-flags:
	@echo $(JAVA_PREFIX) $(JAVA) $(RUN_JAVA_FLAGS)

.PHONY: show-run-java-with-flags-and-package
show-run-java-with-flags-and-package:
	@echo $(JAVA_PREFIX) $(JAVA) $(RUN_JAVA_FLAGS) $(PACKAGE)

.PHONY: show-bin
show-bin:
	@echo $(BIN)

.PHONY: show-cs-bin
show-cs-bin:
	@echo $(CS_BIN)

.PHONY: show-scripts
show-scripts:
	@echo $(SCRIPTS)

.PHONY: show-cs-scripts
show-cs-scripts:
	@echo $(CS_SCRIPTS)

.PHONY: show-settings
show-settings:
	@echo Make settings:
	@echo APPNAME: $(APPNAME)
	@echo BASE_PACKAGE: $(BASE_PACKAGE)
	@echo ARCH: $(ARCH)
	@echo TOOLS_HOME: $(TOOLS_HOME)
	@echo TOOLS_JAR: $(TOOLS_JAR)
	@echo SCRIPTS: $(SCRIPTS)
	@echo CS_SCRIPTS: $(CS_SCRIPTS)
	@echo CS_BIN: $(CS_BIN)
	@echo CS_ENSURE: $(CS_ENSURE)
	@echo CS_SUBMIT: $(CS_SUBMIT)
	@echo JDK_BASE: $(JDK_BASE)
	@echo JDK_HOME: $(JDK_HOME)
	@echo JDK_EXT: $(JDK_EXT)
	@echo TOOLS_EXT: $(TOOLS_EXT)
	@echo EXT_DIR: $(EXT_DIR)
	@echo JDK_VERSION: $(JDK_VERSION)
	@echo SOURCE_VERSION: $(SOURCE_VERSION)
	@echo TARGET_VERSION: $(TARGET_VERSION)
	@echo JAVAC: $(JAVAC)
	@echo JAVA: $(JAVA)
	@echo JAVADOC: $(JAVADOC)
	@echo JAVACC: $(JAVACC)
	@echo JAR: $(JAR)
	@echo NO_COMPILE_SERVER: "$(NO_COMPILE_SERVER)"
	@echo USING_COMPILE_SERVER: "$(USING_COMPILE_SERVER)"
	@echo SHELL: $(SHELL)
	@echo CD: $(CD)
	@echo PROJECT: $(PROJECT)
	@echo PROJECT_HOME: $(PROJECT_HOME)
ifdef ROOT_PACKAGE
	@echo this is the root package
else
	@echo this is not the root package
endif
	@echo PACKAGE: $(PACKAGE)
	@echo PACKAGE_PATH: '$(PACKAGE_PATH)'
	@echo PACKAGE_NAME: $(PACKAGE_NAME)
	@echo EXCLUDE_SUBDIRS: $(EXCLUDE_SUBDIRS)
	@echo PACKAGE_SUBDIRS: $(PACKAGE_SUBDIRS)
	@echo EXCLUDE_SOURCE: $(EXCLUDE_SOURCE)
	@echo PACKAGE_JAVAC_SOURCE: $(PACKAGE_JAVAC_SOURCE)
	@echo PACKAGE_HTML_SOURCE: $(PACKAGE_HTML_SOURCE)
	@echo PACKAGE_JAVACC_SOURCE: $(PACKAGE_JAVACC_SOURCE)
	@echo PACKAGE_JAVAC_DEPS: $(PACKAGE_JAVAC_DEPS)
	@echo PACKAGE_HTML_DEPS: $(PACKAGE_HTML_DEPS)
	@echo EXTRA_PACKAGE_DEPS: $(EXTRA_PACKAGE_DEPS)
	@echo EXTRA_CLEAN_DEPS: $(EXTRA_CLEAN_DEPS)
	@echo GEN_MD: $(GEN_MD)
	@echo HTML_M4_EXTRA_DEPS: $(HTML_M4_EXTRA_DEPS)
	@echo MD_M4D_EXTRA_DEPS: $(MD_M4D_EXTRA_DEPS)
	@echo HTEX_MD_EXTRA_DEPS: $(HTEX_MD_EXTRA_DEPS)
	@echo HTML_HTEX_EXTRA_DEPS: $(HTML_HTEX_EXTRA_DEPS)
	@echo PACKAGE_JAVACC_DEPS: $(PACKAGE_JAVACC_DEPS)
	@echo PACKAGE_DEPS: $(PACKAGE_DEPS)
	@echo SOURCE: $(SOURCE)
	@echo SUBPROJECT_PACKAGES: $(SUBPROJECT_PACKAGES)
	@echo JAVAC_FLAGS: '$(JAVAC_FLAGS)'
	@echo JAVADOC_FLAGS: '$(JAVADOC_FLAGS)'
	@echo JAVADOC_DIR: $(JAVADOC_DIR)
	@echo JARFILE_PAT: $(JARFILE_PAT)
	@echo JARFILE_LITE_PAT: $(JARFILE_LITE_PAT)
	@echo JARFILE_XLITE_PAT: $(JARFILE_XLITE_PAT)
	@echo JARFILE_NEWEST: $(JARFILE_NEWEST)
	@echo JARFILE_LITE_NEWEST: $(JARFILE_LITE_NEWEST)
	@echo JARFILE_XLITE_NEWEST: $(JARFILE_XLITE_NEWEST)
	@echo JARFILE: $(JARFILE)
	@echo JARFILE_LITE: $(JARFILE_LITE)
	@echo JARFILE_XLITE: $(JARFILE_XLITE)
	@echo PROJECT_JAR_TARGETS: $(PROJECT_JAR_TARGETS)
	@echo JARFILE_SUBST: $(JARFILE_SUBST)
	@echo JARFILE_LITE_SUBST: $(JARFILE_LITE_SUBST)
	@echo JARFILE_XLITE_SUBST: $(JARFILE_XLITE_SUBST)
	@echo JARFILE_PUBLISH_UNPACK_SUBST: $(JARFILE_PUBLISH_UNPACK_SUBST)
	@echo JAR_EXTRA: $(JAR_EXTRA)
	@echo JAR_LITE_EXTRA: $(JAR_LITE_EXTRA)
	@echo JAR_XLITE_EXTRA: $(JAR_XLITE_EXTRA)
	@echo JAR_EXTRA_CMDS: '$(JAR_EXTRA_CMDS)'
	@echo JAR_LITE_EXTRA_CMDS: '$(JAR_LITE_EXTRA_CMDS)'
	@echo JAR_XLITE_EXTRA_CMDS: '$(JAR_XLITE_EXTRA_CMDS)'
	@echo JAR_DIR: $(JAR_DIR)
	@echo JAR_MF: $(JAR_MF)
	@echo JARKEY: $(JARKEY)
	@echo JAR_CRT: $(JAR_CRT)
	@echo EXT_JARS: $(EXT_JARS)
	@echo MAKE_CLASSPATH: '$(MAKE_CLASSPATH)'
	@echo MAKE_SOURCEPATH: '$(MAKE_SOURCEPATH)'
	@echo SUBPACKAGE_MAKEFILES: $(SUBPACKAGE_MAKEFILES)
	@echo PUBLISH_DEST: $(PUBLISH_DEST)
	@echo SVNVERSION_STRING: $(SVNVERSION_STRING)
	@echo SVNVERSION_FILE: $(SVNVERSION_FILE)

# package targets

# make the current package
.PHONY: package
package: $(EXTRA_PACKAGE_DEPS) $(PACKAGE_DEPS)
	$(EXTRA_PACKAGE_CMDS)

.PHONY: package-javac
package-javac: $(PACKAGE_JAVAC_DEPS)

.PHONY: package-source-gen
package-source-gen: package-javacc

# make javacc in the current package
.PHONY: package-javacc
package-javacc: $(PACKAGE_JAVACC_DEPS)

# make html in the current package
.PHONY: package-html
package-html: $(PACKAGE_HTML_DEPS)

# make the makefile in the current package
ifndef ROOT_PACKAGE
makefile: $(PROJECT_HOME)/makefile
	@$(CD) .. && $(MAKE) $(PACKAGE_NAME)/makefile
else
makefile: FORCE
endif

.PHONY: clean
clean: $(EXTRA_CLEAN_DEPS)
	@echo removing all .class files in this package 
	$(RM) *.class

.PHONY: c-clean
c-clean:
	@echo removing all .o files in this package 
	$(RM) *.o

.PHONY: javacc-clean
javacc-clean:
	@echo removing javacc-generated files
	$(RM) `ls *.java | xargs grep -l "Generated By:JavaCC"`

.PHONY: rmiwrap-clean
rmiwrap-clean:
	@echo removing RMIWrap-generated files
	$(RM) `ls *.java | xargs grep -l "generated by RMIWrap"`

.PHONY: svnversion-clean
svnversion-clean:
	@echo removing generated $(SVNVERSION_FILE)
	$(RM) $(SVNVERSION_FILE)

.PHONY: html-clean
html-clean:
	@echo removing all generated html
	$(RM) $(PACKAGE_HTML_DEPS)
	$(RM) $(GEN_MD)
	$(RM) -f gen-*.html *.htex
	$(RM) -rf gen-images-*

.PHONY: jar-clean
jar-clean:
#	$(RM) $(JARFILE_PAT) $(JARFILE_LITE_PAT) $(JARFILE_XLITE_PAT)
#	$(RM) $(JARFILE_NEWEST) $(JARFILE_LITE_NEWEST) $(JARFILE_XLITE_NEWEST)
	$(RM) $(APPNAME)-*.jar

.PHONY: javadoc-clean
javadoc-clean:
	$(RM) -r $(JAVADOC_DIR)

.PHONY: realclean
realclean: $(EXTRA_REALCLEAN_DEPS) clean rmiwrap-clean javacc-clean html-clean jar-clean javadoc-clean $(if $(SVNVERSION_FILE_NOAUTO),,svnversion-clean)
	if [ -f core ]; then $(RM) core; fi

.PHONY: show-svnversion
show-svnversion:
	$(SVNVERSION)

.PHONY: show-svnversion-string
show-svnversion-string:
	@echo $(SVNVERSION_STRING)

.PHONY: show-svnversion-file-dep
show-svnversion-file-dep:
	@echo $(SVNVERSION_FILE_DEP)

$(SVNVERSION_FILE): FORCE
	$(SVNVERSION) > $@
	date +%Y-%m-%d >> $@

# project targets

.PHONY: project-announce
project-announce:
	@echo making project

.PHONY: project
project: project-announce $(if $(NO_SOURCE_GEN),,project-source-gen)
	$(call make-from-project-home,package.recursive)

.PHONY: project-javacc
project-javacc:
	$(call make-from-project-home,package-javacc.recursive)

.PHONY: project-source-gen
project-source-gen:
	$(call make-from-project-home,package-source-gen.recursive)

.PHONY: project-html
project-html:
	$(call make-from-project-home,package-html.recursive)

.PHONY: project-javadoc
project-javadoc:
	$(call make-from-project-home,subproject-javadoc)

.PHONY: subproject-javadoc
subproject-javadoc:
	if [ "$(SUBPROJECT_PACKAGES)" ]; then $(call javadoc,$(SUBPROJECT_PACKAGES),$(EXCLUDE_JAVADOC_PACKAGES)); fi

.PHONY: project-clean
project-clean:
	$(call make-from-project-home,clean.recursive)

.PHONY: project-realclean
project-realclean:
	$(call make-from-project-home,realclean.recursive)

.PHONY: project-show-svnversion
project-show-svnversion:
	$(call make-from-project-home,show-svnversion)

.PHONY: project-$(SVNVERSION_FILE)
project-SVNVERSION.txt:
	$(call make-from-project-home,$(SVNVERSION_FILE))

$(SUBPACKAGE_MAKEFILES): makefile
	@if [ -e $@ ] && [ `grep -c super-ninja $@ 2> /dev/null ` -eq 0 ]; \
	then echo "$@ exists but is not super-ninja, skipping"; \
	else echo "(re)making $@" && \
	$(RM) $@ && \
	sed \
	-e 's|^$(WS)PROJECT_HOME$(WS)=$(WS)\(.*\)$(WS)|PROJECT_HOME = ../\1|' \
	-e 's/^$(WS)PACKAGE$(WS)=$(WS)\(.*\)$(WS)/PACKAGE = \1.$(subst /,,$(dir $@))/' \
  -e 's/^$(WS)if-root-package$(WS)=.*/if-root-package = $$(2)/' \
  makefile > $@; fi

.PHONY: makefiles
makefiles: $(SUBPACKAGE_MAKEFILES)
	@echo making makefiles
	@$(call recursively-make,makefiles,true)

# make the jar key
.PHONY: keygen
keygen:
	$(JDK_HOME)/bin/keytool -genkey -keyalg rsa -alias $(JARKEY)
	$(JDK_HOME)/bin/keytool -export -alias $(JARKEY) -file $(JAR_CRT)

# make the jar
#
# the jar is built containing all rsync-able files in all
# $(SUBPROJECT_PACKAGES), the subproject javadoc, and the makefile from the
# base package.  Subproject packages ending in "." are copied non-recursively,
# else they are copied recursively.
#
# empty dirs will not be included in the jar
#
# all $(EXT_JARS), if any, are folded into the jarfile
#
# if $(JAR_MF) exists it is used as the jar manifest
#
# if $(JAR_CRT) exist the jar is signed with $(JARKEY)
.PHONY: jar 
jar: $(SVNVERSION_FILE_DEP)
	$(MAKE) jar-impl
.PHONY: jar-impl
jar-impl:
	$(call make-jar,true,$(EXT_JARS),$(JARFILE_SUBST),$(JARFILE_EXTS),$(JAR_EXTRA),$(SUBPROJECT_PACKAGES),$(JARFILE_NEWEST),$(JAR_EXTRA_CMDS))

# make the lite jar
#
# same as the "jar" target except uses LITE_SUBPROJECT_PACKAGES, EXT_JARS_LITE,
# JARFILE_LITE_EXTS, JAR_LITE_EXTRA, and never includes the javadoc tree
.PHONY: jar-lite
jar-lite: $(SVNVERSION_FILE_DEP)
	$(MAKE) jar-lite-impl
.PHONY: jar-lite-impl
jar-lite-impl:
	$(call make-jar,false,$(EXT_JARS_LITE),$(JARFILE_LITE_SUBST),$(JARFILE_LITE_EXTS),$(JAR_LITE_EXTRA),$(LITE_SUBPROJECT_PACKAGES),$(JARFILE_LITE_NEWEST),$(JAR_LITE_EXTRA_CMDS))

# make the xlite jar
#
# same as the "jar-lite" target except uses XLITE_SUBPROJECT_PACKAGES,
# EXT_JARS_XLITE, JARFILE_XLITE_EXTS, and JAR_XLITE_EXTRA
.PHONY: jar-xlite
jar-xlite: $(SVNVERSION_FILE_DEP)
	$(MAKE) jar-xlite-impl
.PHONY: jar-xlite-impl
jar-xlite-impl:
	$(call make-jar,false,$(EXT_JARS_XLITE),$(JARFILE_XLITE_SUBST),$(JARFILE_XLITE_EXTS),$(JAR_XLITE_EXTRA),$(XLITE_SUBPROJECT_PACKAGES),$(JARFILE_XLITE_NEWEST),$(JAR_XLITE_EXTRA_CMDS))

.PHONY: jars
jars: $(PROJECT_JAR_TARGETS)

# publish to PUBLISH_DEST
#
# rsyncs $(JARFILE_SUBST) (and $(JARFILE_LITE_SUBST), and
# $(JARFILE_XLITE_SUBST), if any) there AND rsync's
# $(JARFILE_PUBLISH_UNPACK_SUBST)'s contents there
.PHONY: publish
ifdef PUBLISH_DEST
publish: $(SVNVERSION_FILE_DEP)
	$(MAKE) publish-impl
.PHONY: publish-impl
publish-impl:
	@echo publishing to $(PUBLISH_DEST)
	if [ $(JARFILE_PUBLISH_UNPACK_SUBST) ]; then \
		mkdir .$(JARFILE_PUBLISH_UNPACK_SUBST)-unpack.tmp; \
		cd .$(JARFILE_PUBLISH_UNPACK_SUBST)-unpack.tmp && $(JAR) xvf ../$(JARFILE_PUBLISH_UNPACK_SUBST) && $(call rsync,*,$(PUBLISH_DEST)); \
		cd .. && rm -rf .$(JARFILE_PUBLISH_UNPACK_SUBST)-unpack.tmp; \
	fi
	if [[ "$(JARFILE_SUBST)"x != x && -f $(JARFILE_SUBST) ]]; then \
		$(call rsync,$(JARFILE_SUBST),$(PUBLISH_DEST)); \
		if [[ -h $(JARFILE_NEWEST) ]]; then $(call rsync,$(JARFILE_NEWEST),$(PUBLISH_DEST)); fi \
	fi
	if [[ "$(JARFILE_LITE_SUBST)"x != x && -f $(JARFILE_LITE_SUBST) ]]; then \
		$(call rsync,$(JARFILE_LITE_SUBST),$(PUBLISH_DEST)); \
		if [[ -h $(JARFILE_LITE_NEWEST) ]]; then $(call rsync,$(JARFILE_LITE_NEWEST),$(PUBLISH_DEST)); fi \
	fi
	if [[ "$(JARFILE_XLITE_SUBST)"x != x && -f $(JARFILE_XLITE_SUBST) ]]; then \
		$(call rsync,$(JARFILE_XLITE_SUBST),$(PUBLISH_DEST));  \
		if [[ -h $(JARFILE_XLITE_NEWEST) ]]; then $(call rsync,$(JARFILE_XLITE_NEWEST),$(PUBLISH_DEST)); fi \
	fi
	$(EXTRA_PUBLISH_CMDS)
else
publish:
	@echo PUBLISH_DEST not set
	$(EXTRA_PUBLISH_CMDS)
endif

# publish to PUBLISH_DEST
#
# rsyncs $(JARFILE_LITE_SUBST) there
.PHONY: publish-lite
ifdef PUBLISH_DEST
publish-lite: $(SVNVERSION_FILE_DEP)
	$(MAKE) publish-lite-impl
.PHONY: publish-lite-impl
publish-lite-impl:
	@echo publishing to $(PUBLISH_DEST)
	$(call rsync,$(JARFILE_LITE_SUBST),$(PUBLISH_DEST))
	cd $(PUBLISH_DEST) && ln -s -f $(JARFILE_LITE_SUBST) $(JARFILE_LITE_NEWEST)
	$(EXTRA_PUBLISH_CMDS)
else
publish-lite:
	@echo PUBLISH_DEST not set
	$(EXTRA_PUBLISH_CMDS)
endif


